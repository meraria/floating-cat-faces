<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Floating Cat Faces</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            min-height: -webkit-fill-available;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            overflow: hidden;
            touch-action: none;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }
        
        canvas {
            display: block;
            touch-action: none;
        }
    </style>
</head>
<body>
    <script>
        let cats = [];
        let draggedCat = null;
        let gravity = 0.0; // Zero gravity - cats won't float to top (0.0 = no upward force, 0.05 = light float up, 0.08+ = floats to top)
        let damping = 0.995; // Less resistance for space-like movement (0.98 = normal, 0.995 = space-like, 1.0 = no resistance)
        let isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        let touchStartX = 0;
        let touchStartY = 0;
        let lastTouchTime = 0;
        let lastTouchX = 0;
        let lastTouchY = 0;
        let doubleTapDelay = 300; // milliseconds for double tap detection
        
        function setup() {
            createCanvas(windowWidth, windowHeight);
            pixelDensity(1); // Optimize for mobile performance
            
            // Adjust number of cats based on device
            let numCats = isMobile ? 4 : 6;
            
            // Create ragdoll cats with random positions
            for (let i = 0; i < numCats; i++) {
                cats.push(createRagdollCat(random(100, width - 100), random(100, height - 100)));
            }
            
            // Prevent default touch behaviors
            document.addEventListener('touchstart', function(e) {
                if (e.touches.length > 1) {
                    e.preventDefault();
                }
            }, { passive: false });
            
            document.addEventListener('touchmove', function(e) {
                if (e.touches.length > 1) {
                    e.preventDefault();
                }
            }, { passive: false });
            
            document.addEventListener('touchend', function(e) {
                e.preventDefault();
            }, { passive: false });
        }
        
        function createRagdollCat(x, y) {
            // Smaller cats on mobile for better performance
            let minSize = isMobile ? 50 : 70;
            let maxSize = isMobile ? 85 : 110;
            
            return {
                x: x,
                y: y,
                vx: random(-3, 3), // Faster initial velocity for space-like movement
                vy: random(-3, 3),
                size: random(minSize, maxSize),
                rotation: 0,
                rotationSpeed: random(-0.03, 0.03), // More rotation
                isDragging: false,
                floatOffset: random(0, TWO_PI), // For floating animation
                floatSpeed: random(0.02, 0.05) // Speed of floating motion
            };
        }
        
        function draw() {
            background(240, 248, 255); // Lighter blue background (RGB: very light blue)
            
            // Update and draw each cat
            for (let cat of cats) {
                if (!cat.isDragging) {
                    // Apply gravity (upward force for floating effect)
                    cat.vy -= gravity;
                    
                    // Add floating motion (gentle drift) - increase multiplier for more space-like drift
                    cat.floatOffset += cat.floatSpeed;
                    let floatX = cos(cat.floatOffset) * 1.0; // Increased from 0.5 for more space-like movement
                    let floatY = sin(cat.floatOffset * 0.7) * 1.0; // Increased from 0.5 for more space-like movement
                    
                    // Update position with floating motion
                    cat.x += cat.vx + floatX;
                    cat.y += cat.vy + floatY;
                    
                    // Apply damping (air resistance)
                    cat.vx *= damping;
                    cat.vy *= damping;
                    
                    // Bounce off edges with some energy loss
                    if (cat.x < cat.size/2) {
                        cat.x = cat.size/2;
                        cat.vx *= -0.7;
                    }
                    if (cat.x > width - cat.size/2) {
                        cat.x = width - cat.size/2;
                        cat.vx *= -0.7;
                    }
                    // Prevent cats from floating to the top - keep them in middle/lower area
                    if (cat.y < height * 0.15) { // Keep cats from going to very top
                        cat.y = height * 0.15;
                        cat.vy *= -0.7;
                    }
                    if (cat.y > height - cat.size/2) {
                        cat.y = height - cat.size/2;
                        cat.vy *= -0.7;
                    }
                    
                    cat.rotation += cat.rotationSpeed;
                }
                
                // Draw cat
                push();
                translate(cat.x, cat.y);
                rotate(cat.rotation);
                drawRagdollCat(0, 0, cat.size);
                pop();
            }
        }
        
        function drawRagdollCat(x, y, size) {
            let s = size / 80; // Scale factor
            
            // Head (cream/white color)
            fill(250, 245, 235);
            stroke(0);
            strokeWeight(2 * s);
            ellipse(x, y, 60 * s, 50 * s);
            
            // Dark points on ears (seal point coloring)
            fill(100, 90, 80);
            triangle(x - 25 * s, y - 20 * s, x - 15 * s, y - 10 * s, x - 10 * s, y - 25 * s);
            triangle(x + 25 * s, y - 20 * s, x + 15 * s, y - 10 * s, x + 10 * s, y - 25 * s);
            
            // Inner ears (pink)
            fill(255, 200, 210);
            noStroke();
            triangle(x - 22 * s, y - 18 * s, x - 16 * s, y - 13 * s, x - 13 * s, y - 22 * s);
            triangle(x + 22 * s, y - 18 * s, x + 16 * s, y - 13 * s, x + 13 * s, y - 22 * s);
            
            // Eyes (distinctive blue eyes of ragdolls)
            fill(135, 206, 250); // Sky blue
            stroke(0);
            strokeWeight(2 * s);
            ellipse(x - 15 * s, y - 5 * s, 16 * s, 22 * s);
            ellipse(x + 15 * s, y - 5 * s, 16 * s, 22 * s);
            
            // Pupils
            fill(0);
            noStroke();
            ellipse(x - 15 * s, y - 3 * s, 6 * s, 14 * s);
            ellipse(x + 15 * s, y - 3 * s, 6 * s, 14 * s);
            
            // Eye highlights
            fill(255);
            ellipse(x - 13 * s, y - 7 * s, 5 * s, 5 * s);
            ellipse(x + 17 * s, y - 7 * s, 5 * s, 5 * s);
            
            // Dark mask on face (color point)
            fill(100, 90, 80, 100);
            noStroke();
            ellipse(x, y + 5 * s, 40 * s, 25 * s);
            
            // Nose (darker)
            fill(80, 70, 60);
            stroke(0);
            strokeWeight(1.5 * s);
            triangle(x - 3 * s, y + 5 * s, x + 3 * s, y + 5 * s, x, y + 10 * s);
            
            // Mouth
            noFill();
            stroke(0);
            strokeWeight(2 * s);
            arc(x - 8 * s, y + 10 * s, 10 * s, 8 * s, 0, PI);
            arc(x + 8 * s, y + 10 * s, 10 * s, 8 * s, 0, PI);
            
            // Whiskers (white)
            stroke(255);
            strokeWeight(1.5 * s);
            line(x - 30 * s, y, x - 45 * s, y - 5 * s);
            line(x - 30 * s, y + 5 * s, x - 45 * s, y + 5 * s);
            line(x - 30 * s, y + 10 * s, x - 45 * s, y + 15 * s);
            line(x + 30 * s, y, x + 45 * s, y - 5 * s);
            line(x + 30 * s, y + 5 * s, x + 45 * s, y + 5 * s);
            line(x + 30 * s, y + 10 * s, x + 45 * s, y + 15 * s);
            
            // Fluffy cheeks
            fill(250, 245, 235);
            noStroke();
            ellipse(x - 30 * s, y + 8 * s, 12 * s, 10 * s);
            ellipse(x + 30 * s, y + 8 * s, 12 * s, 10 * s);
        }
        
        function mousePressed() {
            touchStartX = mouseX;
            touchStartY = mouseY;
            handleInteraction(mouseX, mouseY);
        }
        
        function touchStarted() {
            if (touches.length > 0) {
                let touch = touches[0];
                let currentTime = Date.now();
                let timeSinceLastTouch = currentTime - lastTouchTime;
                let distance = dist(touch.x, touch.y, lastTouchX, lastTouchY);
                
                // Check for double tap (within time and distance threshold)
                if (timeSinceLastTouch < doubleTapDelay && distance < 50 && !draggedCat) {
                    // Double tap detected - add new cat at tap location
                    cats.push(createRagdollCat(touch.x, touch.y));
                    lastTouchTime = 0; // Reset to prevent triple tap
                    return false;
                }
                
                touchStartX = touch.x;
                touchStartY = touch.y;
                lastTouchX = touch.x;
                lastTouchY = touch.y;
                lastTouchTime = currentTime;
                handleInteraction(touch.x, touch.y);
            }
            return false; // Prevent default
        }
        
        function handleInteraction(x, y) {
            // Check if interaction is over any cat
            for (let i = cats.length - 1; i >= 0; i--) {
                let cat = cats[i];
                let d = dist(x, y, cat.x, cat.y);
                if (d < cat.size / 2) {
                    draggedCat = cat;
                    cat.isDragging = true;
                    // Store initial position for velocity calculation
                    touchStartX = x;
                    touchStartY = y;
                    cat.vx = 0;
                    cat.vy = 0;
                    return;
                }
            }
        }
        
        function mouseDragged() {
            if (draggedCat) {
                // Smooth dragging with mouse
                draggedCat.x = mouseX;
                draggedCat.y = mouseY;
            }
        }
        
        function touchMoved() {
            if (draggedCat && touches.length > 0) {
                let touch = touches[0];
                // Smooth dragging
                draggedCat.x = touch.x;
                draggedCat.y = touch.y;
                // Update last position for double tap detection
                lastTouchX = touch.x;
                lastTouchY = touch.y;
            }
            return false; // Prevent scrolling
        }
        
        function mouseReleased() {
            if (draggedCat) {
                // Calculate velocity from mouse movement
                let dragDistance = dist(mouseX, mouseY, touchStartX, touchStartY);
                if (dragDistance > 10) {
                    draggedCat.vx = (mouseX - pmouseX) * 0.3;
                    draggedCat.vy = (mouseY - pmouseY) * 0.3;
                }
            }
            releaseCat();
        }
        
        function touchEnded() {
            let touch = touches.length > 0 ? touches[0] : null;
            
            if (draggedCat && touch) {
                // Calculate velocity from touch movement for smooth release
                let dragDistance = dist(touch.x, touch.y, touchStartX, touchStartY);
                if (dragDistance > 10) { // Only apply velocity if actually dragged
                    draggedCat.vx = (touch.x - touchStartX) * 0.25;
                    draggedCat.vy = (touch.y - touchStartY) * 0.25;
                }
            }
            releaseCat();
            
            return false;
        }
        
        function releaseCat() {
            if (draggedCat) {
                draggedCat.isDragging = false;
                draggedCat = null;
            }
        }
        
        function doubleClicked() {
            // Add a new ragdoll cat where the user double-clicks (desktop only)
            // Only add if not dragging a cat
            if (!isMobile && !draggedCat) {
                cats.push(createRagdollCat(mouseX, mouseY));
            }
        }
        
        function windowResized() {
            resizeCanvas(windowWidth, windowHeight);
            // Reposition cats if they're outside bounds after resize
            for (let cat of cats) {
                if (cat.x < cat.size/2) cat.x = cat.size/2;
                if (cat.x > width - cat.size/2) cat.x = width - cat.size/2;
                if (cat.y < cat.size/2) cat.y = cat.size/2;
                if (cat.y > height - cat.size/2) cat.y = height - cat.size/2;
            }
        }
    </script>
</body>
</html>

